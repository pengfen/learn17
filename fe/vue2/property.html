前端性能优化点 构建层面 浏览器渲染层面 服务端层面 网络层面

资源的合并与压缩
图片编解码原理和类型选择
浏览器渲染机制
懒加载预加载

chrome的调优工具 performance layers
前端性能优化原理 作用及原理 如何与真实业务场景结合 理论结合实践 量化分析

基础优化 进阶优化 结合服务端的优化

学前要求
掌握前端基础知识如html css js
有性能优化原理有好奇和探究的兴趣

理论讲解 了解某个性能优化点背后的原理
案例分析 结合一些知名网站的case分析大公司的应用
代码实战 在实战中加强应用和体会
场景分析 为性能优化点寻找最适合的业务场景

深入掌握性能优化的原理
了解当前大公司在性能优化上所做的实践
学会分析自身业务 选择合适的性能优化方式
全面地了解前端性能优化 轻松hold性能优化面试题 让性能优化成为你前端面试的高分项

资源的合并与压缩
理解减少http请求数量和减少请求资源大小两个优化要点
掌握压缩与合并的原理
掌握通过在线网站和fis3两种实现压缩与合并的方法

web前端本质上是一种GUI软件 本可以直接借鉴其他GUI系统架设计方法 但web前端有点特别
CS架构GUI软件的开发与部署过程 开发 发布 运行

浏览器的一个请求从发送到返回都经历了什么

请求过程中一些潜在的性能优化点
dns是否可以通过缓存减少dns查询时间
网络请求的过程走最后的网络环境
相同的静态资源是否可以缓存
能否减少请求http请求大小
减少http请求
服务端渲染

资源的合并与压缩 减少http请求数量 减少请求资源的大小

google首页案例学习
html压缩 css压缩 js的压缩和混乱 文件合并 开启gzip

html压缩
HTML代码压缩就是压缩这些在文本文件中有意义 但是在HTML中不显示的字符
包括空格 制表符 换行符等 还有一些其他意义的字符 如HTML注释也可以被告压缩
一个简单的计算
google的流量 占到整个互联网的40%
预计2016年全球网络流量将会达到1.3ZB(1ZB=10^9TB)
那么google在2016年的流量就是1.32ZB*40%
如果google每1MB请求减少一个字节
每年可以节省流量近500TB

如何进行html压缩
1.使用在线网站进行压缩
2.nodejs提供了html-minifier工具
3.后端模板引擎渲染压缩

css压缩
无效代码删除
css语义合并

如何进行css压缩
1.使用在线网站进行压缩
2.使用html-minifier对html中的css进行压缩
3.使用clean-css对css进行压缩

Js压缩与混乱
无效字符的删除
剔除注释
代码语义的缩减和优化
代码保护

如何进行js压缩和混乱
1.使用在线网站进行压缩
2.使用html-minifier对html中的js进行压缩
3.使用uglifyjs2对js进行压缩

文件合并
文件与文件这间有插入的上行请求 增加了N-1个网络延迟
受丢包问题影响更严重
经过代理服务器时可能会被断开

文件合并存在的问题
首屏渲染问题
缓存失效问题

公共库合并
不同页面的合并
见机行事 随机应变

文件合并
如何进行文件合并
1.使用在线网站进行文件合并
2.使用nodejs实现文件合并

新闻列表页面实战
新闻列表页面代码开发
使用网站进行压缩与合并
使用fis进行自动化的压缩与合并

课程总结
web前端的核心概念和web前端性能优化的意义所在
http请求的过程及其中潜在的性能优化点
压缩与合并的基本理念和使用
在实战中体会和掌握本节课的内容在业务中的真实使用

图片相关的优化
理解图片相关的优化的核心概念
结合facebook和淘宝移动首页案例分析
掌握通过在线网站和fis3两种实现图片相关的一些优化

png8 png24 png32 之间的区别
png8 256色 + 支持透明
png24 2^24色 + 不支持透明
png32 2^24色 + 支持透明

每种图片格式都有自己的特点 针对不同的业务场景选择不同的图片格式很重要

不同格式图片常用的业务场景
jpg有损压缩 压缩率高 不支持透明 (大部分不需要透明图片的业务场景)
png支持透明 浏览器兼容好 (大部分需要透明图片的业务场景)
webp压缩程序更好 在ios webview有兼容性问题 (安卓全部)
svg矢量图 代码内嵌 相对较小 图片样式相对简单的场景 (图片样式相对简单的业务场景)

进行图片压缩
针对真实图片情况 舍弃一些相对无关紧要的色彩信息

CSS雪碧图
把你的网站上乃至的一些图片整合到一张单独的图片中
减少你的网站的HTTP请求数量 (缺点 整合图片比较大时 一次加载比较慢)

Image inline 将图片的内容内嵌到html当中
减少你的网站的HTTP请求数量

使用矢量图
使用SVG进行矢量图的绘制 使用iconfont解决icon问题

在安卓下使用webp
webp的优势体现在它具有更优的图像数据压缩算法 能带来更小的图片体积 
而且拥有肉眼识别无差异的图像质量 同时具备了无损和有损的压缩模式 
Alpha 透明以及动画的特性 在JPEG和PNG上的转化效果都非常优秀 稳定和统一

css js的加载与执行
理解浏览器端html css js的加载过程
结合chrome的能力学习掌握css js加载过程中的优化点
通过案例分析和实战演练深入理解学习的优化点

html页面加载渲染的过程
HTML --- DOM   
                Render Tree --- Layout --- Paint
CSS --- CSSDOM 

HTML渲染过程的一些特点
顺序执行 并发加载
是否阴塞
依赖关系
引入方式

词法分析 并发加载 并发上限

css阻塞
css head中阻塞页面的渲染
css阻塞js的执行
css不阻塞外部脚本的加载

js阻塞
直接引入的js阻塞页面的渲染
js不阻塞资源的加载
js顺序执行 阻塞后续js逻辑的执行

依赖关系
页面渲染依赖于css的加载
js的执行顺序的依赖关系
js逻辑对于dom节点的依赖关系

js引入方式 直接引入 defer async 异步动态引入js
加载和执行的一些优化点
css样式表置顶
用link代替import
js脚本置底
合理使用js的异步加载能力

懒加载和预加载
理解懒加载和预加载的原理
懒加载与预加载案例分析
懒加载与预加载的案例实战

懒加载
图片进入可视区域之后请求图片资源
对于电商等图片很多 页面很长的业务场景适用
减少无效资源的加载
并发加载的资源过多会阻塞js的加载 影响网站的正常使用

预加载
图片等静态资源在使用之前的提前请求
资源使用到时能从缓存中加载 提升用户体验
页展示的依赖关系维护

重绘与回流
理解浏览器重绘与回流的机制
对于一些经典的案例进行分析
重绘与回流的案例实战

css性能让javascript变慢
频繁触发重绘与回流 会导致UI频繁渲染 最终导致js变慢

回流
当render tree中的一部分(或全部)因为元素的规模尺寸 布局 隐藏等改变而需要重新构建 这就称为回流(reflow)
当页面布局和几何属性改变时就需要回流

重绘
当render tree中的一些元素需要更新属性 而这些属性只是影响元素的外观 风格 而不会影响布局的
比如background-color 则就叫称为重绘

回流必将引起重绘而重绘不一定会引起回流

触发页面重布局的属性
盒子模型相关属性会触发重布局
定位属性及浮动也会触发重布局
改变节点内部文字结构也会触发重布局
width top text-align height bottom overflow-y padding left font-weight
margin right overflow display position font-family border-width float
line-height border clear vertical-align min-height while-space font-size

只触发重绘的属性
color border-style border-radius visibility text-decoration background
background-image background-position background-repeat background-size
outline-color outline outline-style outline-width box-shadow

新建DOM的过程
1.获取DOM后分割为多个图层
2.对每个图层的节点计算样式结果(Recalculate style--样式重计算)
3.为每个节点生成图形和位置(Layout--回流和重布局)
4.将每个节点绘制填充到图层位圉中(Paint Setup和Paint--重绘)
5.图层作为纹理上传到GPU
6.符合多个图层到页面上生成最终屏幕图像(Composite Layers--图层重组)

将频繁重绘回流的DOM元素单独作为一个独立图层 那么这个DOM元素的重绘和回流的影响只会在这个图层中
如何将DOM元素变成新的独立图层
Chrome创建图层的条件
1.3D或透视变换CSS属性(perspective transform)
2.使用加速视频解码的<video>节点
3.拥有3D(WebGL)上下文或加速的2D上下文的<canvas>节点
4.混合插件(如Flash)
5.对自己的opacity做CSS动画或使用一个动画webkit变换的元素
6.拥有加速CSS过滤器的元素
7.元素有一个包含复合层的后代节点(一个元素拥有一个子元素 该子元素在自己的层里)
8.元素有一个z-index较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)

1.避免使用触发重绘 回流的CSS属性
2.将重绘 回流的影响范围限制在单独的图层之内
